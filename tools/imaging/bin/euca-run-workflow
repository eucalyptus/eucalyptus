#!/usr/bin/python

# Copyright 2009-2014 Eucalyptus Systems, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/.
#
# Please contact Eucalyptus Systems, Inc., 6755 Hollister Ave., Goleta
# CA 93117, USA or visit http://www.eucalyptus.com/licenses/ if you need
# additional information or have any questions.

# main
import json
import os
import random
import shutil
import subprocess
import tempfile
import urllib2
import time
import argparse
import sys
from eucatoolkit.stages.downloadimage import DownloadImage
from eucatoolkit import get_euca_home

TOTAL_RETRIES=40 # download is retried in case of connection problems (2.5hrs+)
FIRST_TIMEOUT=4  # in seconds, goes in powers of two afterwards
MAX_TIMEOUT=300  # in seconds, the cap for growing timeout values

class WF_InsufficientArguments(RuntimeError):
    pass

class WF_InsufficientDependencies(RuntimeError):
    pass

class WF_ManifestError(IOError):
    pass

# base workflow class

class WF_base():
    def __init__(self):
        self.id = 'unset'
        self.problems = [] # list of problems (implying workflow is not usable)
        self.description = self.__doc__

    def add_arguments(self, name, subparsers):
        pass

    def check_deps(self, args):
        pass

    def execute(self, args):
        self.check_deps(args)
        if len(self.problems) > 0:
            raise WF_InsufficientDependencies(self.problems)
        if hasattr(args, 'pid_path') and args.pid_path is not None:
            f = open(args.pid_path, 'w+')
            f.write(str(os.getpid()))
            f.close()

# specific workflows, one per class

class EucaImager():
    def __init__(self, cache_dir, work_dir, cache_limit_bytes=None, work_limit_bytes=None, debug=True, service_key=None, cloud_cert=None):
        self.cache_dir = cache_dir
        self.work_dir = work_dir
        self.cache_limit_bytes=cache_limit_bytes
        self.work_limit_bytes=work_limit_bytes
        self.debug=debug
        self.service_key=service_key
        self.cloud_cert=cloud_cert
        if (self.cache_limit_bytes == None):
            statfs = os.statvfs(self.cache_dir)
            self.cache_limit_bytes = statfs.f_bavail * statfs.f_bsize
        if (self.work_limit_bytes == None):
            statfs = os.statvfs(self.work_dir)
            self.cache_limit_bytes = statfs.f_bavail * statfs.f_bsize
        self.common_args = ['debug=' + str(self.debug),
                            'cache=' + self.cache_dir,
                            'cache_size=' + str(self.cache_limit_bytes),
                            'work=' + self.work_dir,
                            'work_size=' + str(self.work_limit_bytes)]
        if (self.cloud_cert != None):
            self.common_args.append('cloud_cert=' + self.cloud_cert)
        if (self.service_key != None):
            self.common_args.append('service_key=' + self.service_key)

    def prepare(self, args):
        disk_name='dsk-%s' % (args.emi)
        op_args = [PATHS['euca-imager']] + self.common_args + ['prepare',
                  'boot=yes',
                  'vbr=machine:%s:-1:none:sda1:%s' % (args.emi, args.image_manifest_url),
                  'vbr=kernel:%s:-1:none:none:%s' % (args.eki, args.kernel_manifest_url),
                  'vbr=ramdisk:%s:-1:none:none:%s' % (args.eri, args.ramdisk_manifest_url),
                  'out=' + disk_name]
        _run(op_args)
        return "/dev/mapper/euca-" + disk_name

    def purge(self, args):
        op_args = [PATHS['euca-imager']] + self.common_args + ['purge_cache=yes', 'fsck']
        _run(op_args)


class Euca2ools(object):
    DEFAULT_UPLOAD_ACL = "aws-exec-read" # default canned ACL on AWS for policy-based uploads
    BUNDLE_INSTANCE_ACL = "ec2-bundle-read" # the canned ACL on AWS required for bundle-instance

    def __init__(self):
        self.debug = True

    def bundle_and_upload(self,
                          image_path,
                          destination_dir,
                          args,
                          acl=DEFAULT_UPLOAD_ACL,
                          fd_r=None):
        op_args = [PATHS['euca-bundle-and-upload-image'],
                   '--no-progress',
                   '--image', image_path,
                   '--destination', destination_dir,
                   '--acl', acl,
                   '--prefix', args.prefix,
                   '--arch', args.arch,
                   '--user', args.account,
                   '--access-key-id', args.access_key,
                   '--url', args.object_store_url,
                   '--bucket', args.bucket,
                   '--privatekey', args.signing_key_path,
                   '--cert', args.encryption_cert_path,
                   '--ec2cert', args.encryption_cert_path]
        if hasattr(args, 'eki') and args.eki is not None:
            op_args.extend(['--kernel', args.eki])
        if hasattr(args, 'eri') and args.eri is not None:
            op_args.extend(['--ramdisk', args.eri])
        if hasattr(args, 'secret_key') and args.secret_key is not None:
            op_args.extend(['--secret-key', args.secret_key])
        if hasattr(args, 'image_size') and args.image_size is not None:
            op_args.extend(['--image-size', args.image_size])
        if hasattr(args, 'upload_policy') and args.upload_policy is not None:
            policy = args.upload_policy
            policyObject = None
            try:
                policyObject = json.loads(policy) # try parsing as JSON
            except ValueError:
                policy = args.upload_policy.decode('base64', 'strict')
                policyObject = json.loads(policy) # try parsing again, which should work
            op_args.extend(['--upload-policy', policy])
            if policyObject is not None:
              policyConditions = policyObject.get('conditions')
              if policyConditions is not None:
                for policyCondition in policyConditions:
                  if hasattr( policyCondition, 'get' ):
                    policySecurityToken = policyCondition.get('x-amz-security-token')
                    if policySecurityToken is not None:
                      op_args.extend(['--security-token', policySecurityToken])
                      break
        if hasattr(args, 'upload_policy_signature') and args.upload_policy_signature is not None:
            op_args.extend(['--upload-policy-signature', args.upload_policy_signature])
        if (self.debug):
            op_args.extend(['--debug'])
        op_ps = subprocess.Popen(op_args,
                                 stdin=fd_r,
                                 close_fds=True,
                                 bufsize=-1)
        return op_ps

class WF_DownBundleFS_UpBundle(WF_base):
    """Downloads a file-system bundle, converting to a disk, uploads"""

    def add_arguments(self, id, subparsers):
        self.id = id
        parser = subparsers.add_parser(id, help='a help')
        _add_down_bundle_args(parser)
        parser.add_argument('--kernel-manifest-url', required=True, metavar='URL', help='URL of the download manifest for the kernel bundle')
        parser.add_argument('--ramdisk-manifest-url', required=True, metavar='URL', help='URL of the downlaod manifest for the ramdisk bundle')
        _add_up_bundle_args(parser)
        parser.add_argument('--work-dir', required=True, metavar='PATH', help='Path to the directory where temporary work files are to reside')

    def check_deps(self, args):
        self.problems = _check_euca2ools(self.problems)
        self.problems = _check_imager(self.problems)
        self.problems = _check_bundle_args(self.problems, args)

    def execute(self, args):
        WF_base.execute(self, args)

        cache_dir = tempfile.mkdtemp(dir=args.work_dir, prefix='euca-workflow-cache-')
        work_dir = tempfile.mkdtemp(dir=args.work_dir, prefix='euca-workflow-work-')
        bundle_dir = tempfile.mkdtemp(dir=args.work_dir, prefix='euca-bundle-')
        imager = EucaImager(cache_dir=cache_dir, work_dir=work_dir, work_limit_bytes=512, service_key=args.decryption_key_path, cloud_cert=args.cloud_cert_path)
        euca2ools = Euca2ools()

        try:
            disk_path = imager.prepare(args) # download artifacts and convert partition into a disk
            subprocess.check_call(["ls", "-l", disk_path]) # sanity check, to ensure the disk exists
            op_ps = euca2ools.bundle_and_upload(
                image_path=disk_path,
                destination_dir=bundle_dir,
                args=args) # the rest of the arguments are inherited from run-workflow's command-line
            op_ps.wait() # bundle and upload the disk
            if op_ps.returncode != 0:
                raise subprocess.CalledProcessError(op_ps.returncode, "euca-bundle-and-upload-image")

        finally: # cleanup
            imager.purge(args) # clean up disk artifacts
            shutil.rmtree(cache_dir)
            shutil.rmtree(work_dir)
            shutil.rmtree(bundle_dir)

class WF_DownBundle_WriteRaw(WF_base):
    """Downloads a bundle, writes its contents to a file/device"""

    def add_arguments(self, id, subparsers):
        self.id = id
        parser = subparsers.add_parser(id, help='a help')
        _add_down_bundle_args(parser)
        parser.add_argument('--output-path', required=True, metavar='PATH', help="Path to the file or block device to write output into")

    def check_deps(self, args):
        self.problems = _check_euca2ools(self.problems)

    def execute(self, args):
        WF_base.execute(self, args)

        download = DownloadImage(debug=True, manifest=args.image_manifest_url, destination=args.output_path, privatekey=args.decryption_key_path, cloudcert=args.cloud_cert_path)
        download.main()

class WF_DownParts_WriteRaw(WF_base):
    """Downloads a parts, writes its contents to a file/device"""

    def add_arguments(self, id, subparsers):
        self.id = id
        parser = subparsers.add_parser(id, help='a help')
        parser.add_argument('--output-path', required=True, metavar='PATH', help="Path to the file or block device to write output into")
        parser.add_argument('--import-manifest-url', required=True, metavar='URL', help="URL of the download manifest for the import")
        parser.add_argument('--cloud-cert-path', required=True, metavar='URL', help="Path to the cloud certificate")
        parser.add_argument('--skip-size-validation', required=False, help="Skip downloaded size validation", default=False, action='store_true')

    def check_deps(self, args):
        self.problems = _check_euca2ools(self.problems)

    def execute(self, args):
        WF_base.execute(self, args)
        if args.skip_size_validation:
            download = DownloadImage(reportprogress=True, manifest=args.import_manifest_url, destination=args.output_path, cloudcert=args.cloud_cert_path, skipsizevalidation=True)
        else:
            download = DownloadImage(reportprogress=True, manifest=args.import_manifest_url, destination=args.output_path, cloudcert=args.cloud_cert_path)
        download.main()

class WF_ReadRaw_UpBundle(WF_base):
    """Bundles contents of a local file/disk and uploads it to Object Store"""

    def add_arguments(self, id, subparsers):
        self.id = id
        parser = subparsers.add_parser(id, help='a help')
        parser.add_argument('--input-path', required=True, metavar='PATH', help="Path to the file or block device to read from")
        _add_up_bundle_args(parser)
        parser.add_argument('--work-dir', required=True, metavar='PATH', help='Path to the directory where temporary work files are to reside')

    def check_deps(self, args):
        self.problems = _check_euca2ools(self.problems)

    def execute(self, args):
        WF_base.execute(self, args)

        bundle_dir = tempfile.mkdtemp(dir=args.work_dir, prefix='euca-bundle-')
        euca2ools = Euca2ools()

        try:
            subprocess.call(["ls", "-l", args.input_path]) # sanity check, to ensure the disk exists
            op_ps = euca2ools.bundle_and_upload(
                image_path=args.input_path,
                destination_dir=bundle_dir,
                args=args, # the rest of the arguments are inherited from run-workflow's command-line
                acl=Euca2ools.BUNDLE_INSTANCE_ACL)
            op_ps.wait() # bundle and upload the disk
            if op_ps.returncode != 0:
                raise subprocess.CalledProcessError(op_ps.returncode, "euca-bundle-and-upload-image")

        finally: # cleanup
            shutil.rmtree(bundle_dir)

# helpers for arguments shared by more than one workflow

def _add_down_bundle_args(parser):
    parser.add_argument('--decryption-key-path', required=True, metavar='PATH',  help="Path to the key for decryption")
    parser.add_argument('--image-manifest-url', required=True, metavar='URL', help="URL of the download manifest for the bundle")
    parser.add_argument('--cloud-cert-path', required=True, metavar='URL', help="Path to the cloud certificate")

def _add_up_bundle_args(parser):
    parser.add_argument('--signing-key-path', required=True, metavar='PATH',  help="Path to the key for signing the manifest")
    parser.add_argument('--encryption-cert-path', required=True, metavar='PATH', help="Path to the certificate to use for encrypting the bundle")
    parser.add_argument('--prefix', required=True, metavar='NAME', help="File name prefix to give the bundle's files")
    parser.add_argument('--bucket', required=True, metavar='NAME', help="Name of the bucket to upload the bundle into")
    parser.add_argument('--arch', required=True, metavar='NAME', help="Architecture of the bundled image (e.g., x86_64)")
    parser.add_argument('--account', required=True, metavar='NAME', help="Eucalyptus user account ID")
    parser.add_argument('--access-key', required=True, metavar='NAME', help="Access Key ID on object storage")
    parser.add_argument('--object-store-url', required=True, metavar='URL', help="URL of the object store endpoint")
    parser.add_argument('--emi', required=True, metavar='NAME', help="EMI of the image being bundled")
    # optional arguments
    parser.add_argument('--eki', required=False, metavar='NAME', help="EKI of the kernel to associate with the EMI, if used")
    parser.add_argument('--eri', required=False, metavar='NAME', help="ERI of the ramdisk to associate with the EMI, if used")
    parser.add_argument('--secret-key', required=False, metavar='NAME', help="The secret string for object store account (or --upload-policy)")
    parser.add_argument('--upload-policy', required=False, metavar='PATH', help="Path to upload policy (or --secret-key)")
    parser.add_argument('--upload-policy-signature', required=False, metavar='PATH', help="Path to upload policy signature (or --secret-key)")
    parser.add_argument('--pid-path', required=False, metavar='PATH', help='Path to process PID')

# checking helpers to detect presence of dependencies

def _check_executable(problems, command, dep_name):
    with open(os.devnull, "w") as fnull:
        try:
            err = subprocess.call(command, stdout=fnull, stderr=fnull)
            if (err != 0):
                raise ReferenceError
        except:
            problems.append(dep_name + ' is missing')


def _check_euca2ools(problems):
    _check_executable(problems, [PATHS['euca-version']], "euca2ools (euca-version)")
    _check_executable(problems, [PATHS['euca-bundle-and-upload-image'], '--help'], "euca2ools (bundle-and-upload)")
    return problems

def _check_imager(problems):
    _check_executable(problems, [PATHS['euca-imager'], 'work=/tmp'], "euca-imager") # /tmp is needed so PID file can be created
    return problems

def _check_bundle_args(problems, args):
    if ((args.eki == None) != (args.eri == None)):
        problems.append("both EKI and ERI must be specified")
    if (not ((args.secret_key == None) != (args.upload_policy == None))):
        problems.append("either --secret-key or --upload-policy must be specified")
    if ((args.upload_policy != None) and (args.upload_policy_signature == None)):
        problems.append("both --upload-policy and --upload-policy-signature must be specified")
    return problems
# other helpers

def _download_image(work_dir, name, url, key):
    dest = os.path.join(work_dir, name)
    download = DownloadImage(reportprogress=True, manifest=url, destination=dest, privatekey=key)
    download.main()
    return dest

# TODO: this logic is similar to retry logic in http.c:http_get_timeout()
# and should be unified
def _wait_for_manifest(image_manifest_url):
    timeout = FIRST_TIMEOUT
    manifest = None
    for retry in range(0, TOTAL_RETRIES):
        try:
            print "checking download manifest at " + image_manifest_url
            manifest = urllib2.urlopen(image_manifest_url)
            break
        except urllib2.HTTPError as detail:
            if detail.code != 404 and detail.code != 408:
                print "error: " + str(detail)
                raise WF_ManifestError
        print "manifest not accessible, will retry in " + \
              str(timeout) + " seconds (retry " + \
              str(retry+1) + " of " + str(TOTAL_RETRIES) + ")"
        time.sleep(timeout + random.random()) # randomize retries within a second
        timeout <<= 1
        if timeout > MAX_TIMEOUT:
            timeout = MAX_TIMEOUT
    if manifest == None:
        raise WF_ManifestError
    return manifest

def _run(op_args):
    op_ps = subprocess.Popen(op_args)
    op_ps.wait()
    if op_ps.returncode != 0:
        raise subprocess.CalledProcessError(op_ps.returncode, op_args[0])

WORKFLOWS = {'down-bundle-fs/up-bundle': WF_DownBundleFS_UpBundle(),
             'down-bundle/write-raw': WF_DownBundle_WriteRaw(),
             'read-raw/up-bundle': WF_ReadRaw_UpBundle(),
             'down-parts/write-raw': WF_DownParts_WriteRaw()}

PATHS = {'euca-imager': os.path.join(get_euca_home(), "usr/libexec/eucalyptus", "euca-imager"),
         'euca-version': "euca-version",
         'euca-bundle-and-upload-image': "euca-bundle-and-upload-image"}

# global arguments, apply to all workflows
parser = argparse.ArgumentParser(prog='euca-run-workflow', description='Run an Imaging Toolkit workflow.')
parser.add_argument('-l', '--list', required=False, help='Lists the available workflows', action="store_true")
subparsers = parser.add_subparsers(dest='name', help='Workflows help')

# let each workflow add its own arguments, all as optional
for name in WORKFLOWS:
    WORKFLOWS[name].add_arguments(name, subparsers)
args = parser.parse_args()

if args.list:
    for name in WORKFLOWS:
        if len(WORKFLOWS[name].problems) == 0:
            print "%30s: %s" % (name, WORKFLOWS[name].description)
    sys.exit(0)

# run the desired workflow
try:
    WORKFLOWS[args.name].execute(args)
except KeyError:
    print "unknown workflow '" + args.name + "'"
    sys.exit(2)
except WF_InsufficientArguments, e:
    print "insufficient arguments for workflow '" + args.name + "'"
except WF_InsufficientDependencies, e:
    print "workflow '" + args.name + "' is unavailable! Problems:"
    for problem in e.args[0]:
        print "\t - " + problem
    sys.exit(3)
except WF_ManifestError:
    print "failed to download components from object store"
    sys.exit(4)
except subprocess.CalledProcessError, e:
    print "workflow failed (error in subprocess)"
    sys.exit(5)
